# RCH-02: Slack Socket Mode Reliability Research

**Bead:** `bd-256v.2`  
**Status:** Complete  
**Date:** 2026-02-23  
**Researcher:** IvoryBear (Codex)

---

## Executive Summary

Slack Socket Mode is reliable enough for Quotey’s alpha and early production use if we design around three realities:

1. **Connections are intentionally short-lived and will refresh every few hours.** Reconnect behavior is normal, not exceptional.
2. **Delivery requires explicit acknowledgement using envelope IDs.** Missing ack behavior can trigger retries and duplicate deliveries, so idempotency is mandatory.
3. **Rate limits are not only a posting concern.** API-side quotas and conversation history/replies limits (including 2025-2026 changes) affect backlog recovery and thread reconstruction flows.

Recommended operating model:
- active-active dual socket connections for graceful refresh handling,
- ack-fast ingress path and deferred business processing,
- durable idempotency key store in SQLite,
- bounded retry/backoff and explicit incident playbook for disconnect storms,
- core SLOs and metrics from day one.

---

## 1. Research Scope and Questions

This research evaluates:
- connection lifecycle reliability and reconnect strategy,
- delivery semantics and ordering implications,
- rate limiting impact,
- failure scenario handling,
- operational patterns for production readiness,
- implementation patterns using Rust + slack-morphism.

---

## 2. Primary Findings

## 2.1 Connection Lifecycle

Findings:
- Slack Socket Mode uses dynamic WebSocket URLs generated by `apps.connections.open`.
- URLs refresh regularly; disconnects with `warning` and `refresh_requested` are expected.
- Slack supports up to 10 concurrent Socket Mode connections per app, and payloads may be distributed across open connections without guaranteed affinity.

Implication for Quotey:
- We should not model a single “forever” connection.
- We should maintain at least 2 simultaneous connections during normal operation to avoid downtime during refresh windows.

Design recommendation:
- Maintain **N=2** active connections by default.
- On `warning`/`refresh_requested`, open replacement connection before retiring existing one.

## 2.2 Delivery and Acknowledgement Semantics

Findings:
- Socket Mode event envelopes include `envelope_id` and require acknowledgement.
- Slash command and interaction envelopes may set `accepts_response_payload=true`, allowing immediate response payloads in ack.
- Slack Events API guidance generally emphasizes quick acknowledgement and background processing; the same operational pattern is appropriate for Socket Mode.

Implication:
- App must **ack first** (or as early as possible) and defer heavy work.
- Duplicate deliveries are possible when ack/processing paths fail or reconnect conditions occur.

Design recommendation:
- Split inbound handling into:
  1. parse + validate envelope,
  2. reserve idempotency key,
  3. ack promptly,
  4. queue/process deterministically.

## 2.3 Message Ordering and Throughput

Findings:
- With multiple open connections, Slack may distribute payloads arbitrarily across connections.
- We cannot assume per-connection ordering equals global business ordering.

Implication:
- Per-quote operation ordering must be explicit in our own state model.

Design recommendation:
- Use operation sequencing in SQLite (`quote_id`, `operation_id`, `created_ts`, monotonic sequence where needed).
- Use idempotency + optimistic concurrency on quote version.

## 2.4 Rate Limiting Reality

Findings:
- Web API limits are method/workspace/app based.
- `429` + `Retry-After` handling is mandatory.
- `chat.postMessage` has practical 1 message/sec/channel guidance.
- Events API has 30,000 events per workspace per 60 minutes and emits `app_rate_limited` signals.
- As of March 3, 2026, non-Marketplace distributed apps have stricter limits on `conversations.history` and `conversations.replies` (1 req/min, 15 items) while internal apps are treated differently.

Implication:
- Any high-volume recovery flow depending on history/replies APIs will be constrained.

Design recommendation:
- Prefer event-driven state tracking over frequent history polling.
- Use local SQLite as authoritative timeline; fetch history/replies only when needed.
- Implement method-aware retry scheduler honoring `Retry-After`.

---

## 3. Failure Mode Catalog and Handling Playbook

## 3.1 Network partition / transient connectivity loss

Symptoms:
- disconnect events, reconnect loops, delayed envelopes.

Required behavior:
- exponential backoff with jitter for reconnection attempts,
- preserve operation idempotency across reconnect boundaries,
- avoid duplicate business operations on replay.

## 3.2 Slack-driven connection refresh

Symptoms:
- `disconnect` reason `warning` then `refresh_requested`.

Required behavior:
- pre-open replacement socket,
- drain/retire old socket gracefully,
- maintain uninterrupted ack path.

## 3.3 Token and auth issues

Symptoms:
- `apps.connections.open` failures, auth errors, connection start failures.

Required behavior:
- classify as configuration/security incident,
- fail fast with actionable diagnostics (`doctor` output),
- avoid endless retry with invalid credentials.

## 3.4 API rate-limit saturation

Symptoms:
- HTTP 429 spikes, delayed outbound operations, message posting backlog.

Required behavior:
- honor `Retry-After`,
- method-scoped queues,
- user-visible degraded mode messaging when response latency grows.

## 3.5 Event processing lag / local overload

Symptoms:
- growing queue depth, ack latency drift, stale thread updates.

Required behavior:
- enforce ack-fast design,
- apply backpressure (drop/defers for non-critical updates),
- prioritize mutation commands over informational updates.

---

## 4. Production Reliability Patterns

## 4.1 Connection Management Pattern

Recommended baseline:
- dual active connections,
- periodic health assertions,
- immediate replacement on disconnect,
- reconnect jitter to avoid thundering herd.

## 4.2 Idempotency Pattern

Operation key dimensions:
- envelope ID (transport-level),
- semantic key (quote + command + version),
- payload hash (defense against accidental key collisions).

Storage:
- SQLite idempotency ledger with operation state (`reserved`, `running`, `completed`, `failed`).

## 4.3 Ack and Work Separation

Required contract:
- ack path does minimal work,
- business processing runs in separate task/queue,
- failures after ack are surfaced via follow-up thread/status message and audit events.

## 4.4 Outbound Rate-Limit Control

- per-method/workspace token buckets,
- `Retry-After` aware deferred retries,
- channel write pacing for message methods,
- dead-letter bucket for repeated non-transient failures.

## 4.5 Observability-first Operations

Mandatory metrics:
- socket connect/disconnect counts by reason,
- active connection count,
- envelope ack latency (p50/p95/p99),
- duplicate envelope rate,
- idempotency hit ratio,
- queue depth and processing latency,
- Web API 429 counts per method,
- app_rate_limited event count.

Mandatory logs/spans:
- `correlation_id`, `operation_id`, `envelope_id`, `quote_id`.

---

## 5. Recommended SLOs (Initial)

1. Socket ingress ack p95 under internal threshold (define and tune during load tests).
2. Duplicate business mutations caused by transport retries: **0**.
3. Successful reconnect after refresh/disconnect within bounded window.
4. 429 handling correctness: all retries respect `Retry-After`.
5. Message processing backlog remains below configured queue depth threshold in normal conditions.

---

## 6. Rust/slack-morphism Implementation Notes

Observed from slack-morphism docs/source:
- library supports Socket Mode and multiple websocket connections,
- listener model includes callbacks and disconnect/error hooks,
- internal source demonstrates ack construction from `envelope_id` and client restart behavior on disconnect events.

Implementation implications for Quotey:
- use listener callbacks for thin ingress and deterministic handoff,
- ensure error handler behavior does not accidentally suppress required ack behavior,
- couple reconnect logic with application-level health metrics and stateful idempotency.

---

## 7. Monitoring and Alerting Recommendations

High urgency alerts:
- zero active socket connections for > threshold window,
- sustained ack latency breach,
- repeated `apps.connections.open` failures,
- sustained 429 storm for critical methods,
- idempotency failure leading to duplicate mutation detection.

Medium urgency alerts:
- reconnect frequency anomaly,
- queue depth growth trend,
- app_rate_limited recurring events.

Dashboard groups:
1. Ingress health.
2. Processing pipeline health.
3. Outbound API health.
4. Business integrity (idempotency/replay correctness).

---

## 8. Code Pattern Recommendations (Pseudo-architecture)

1. `socket_ingress`
- parse envelope
- reserve idempotency
- ack
- dispatch operation token

2. `operation_processor`
- load context
- apply deterministic domain command
- persist + audit
- emit outbound effects

3. `outbound_dispatcher`
- method-aware retry/backoff
- rate-limit aware scheduling

4. `reliability_supervisor`
- connection health monitor
- reconnect orchestration
- alert emission hooks

---

## 9. Risk Register for Socket Mode in Quotey

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Duplicate deliveries cause duplicate mutations | Medium | High | durable idempotency ledger |
| Refresh/disconnect causes temporary event loss window | Medium | High | dual connection model + replacement before retire |
| API rate limits degrade user responsiveness | High | Medium | retry scheduler + message pacing + local state-first design |
| Token/config errors cause startup failure | Medium | High | fail-fast validation + doctor checks |
| Unbounded reconnect loops under outage | Medium | Medium | bounded exponential backoff + circuit breaker |

---

## 10. Acceptance Criteria Traceability (`bd-256v.2`)

- **Connection reliability report:** Sections 2.1, 3, 4 complete.
- **Rate limiting strategy:** Sections 2.4 and 4.4 complete.
- **Failure handling playbook:** Section 3 complete.
- **Monitoring/alerting recommendations:** Section 7 complete.
- **Code patterns for reconnection logic:** Sections 4.1 and 8 complete.
- **ADR for connection management:** companion ADR file provided.

Result: `bd-256v.2` deliverables satisfied.

---

## 11. References

1. Slack Socket Mode guide: https://docs.slack.dev/apis/events-api/using-socket-mode  
2. `apps.connections.open` method: https://docs.slack.dev/reference/methods/apps.connections.open/  
3. `connections:write` scope: https://docs.slack.dev/reference/scopes/connections.write/  
4. Slack rate limits: https://docs.slack.dev/apis/web-api/rate-limits/  
5. Events API delivery and `app_rate_limited`: https://docs.slack.dev/apis/events-api/  
6. 2025/2026 rate-limit changes: https://docs.slack.dev/changelog/2025/05/29/rate-limit-changes-for-non-marketplace-apps/  
7. Interaction ack timing (3s): https://docs.slack.dev/interactivity/handling-user-interaction/  
8. Slash command response timing (3s): https://docs.slack.dev/interactivity/implementing-slash-commands  
9. Slack Morphism Socket Mode docs: https://slack-rust.abdolence.dev/socket-mode.html  
10. Slack Morphism source callback/restart behavior: https://docs.rs/slack-morphism/latest/src/slack_morphism/socket_mode/clients_manager_listener.rs.html

