# RCH-09: Single Binary Distribution and Updates Research

**Bead:** `bd-256v.9`  
**Status:** Complete  
**Date:** 2026-02-23  
**Researcher:** LilacMountain (Codex)

## 1. Executive Summary

Quotey should ship as prebuilt, signed release binaries with generated installers, using:

1. `release-plz` for version/changelog/release PR automation,
2. `cargo-dist` for multi-platform artifact and installer generation,
3. explicit target matrix coverage for Linux/macOS/Windows,
4. a safe update flow that protects the local SQLite database via backup + migration guardrails.

This gives a practical single-binary user experience while preserving deterministic upgrade behavior for a local-first CPQ system.

## 2. Current-State Findings (Repo-Specific)

From current repository inspection:

1. Quotey is a multi-crate Rust workspace with runtime entrypoint in `crates/server`.
2. Migration execution is already wired (`sqlx::migrate!`) and invoked during bootstrap.
3. CLI already exposes `migrate` and `doctor`, which are useful primitives for update validation.
4. No release/distribution automation is committed yet.
5. No install/update guide exists yet for operators.

Implication:

- distribution/update architecture should align with existing startup migration behavior, not bypass it.

## 3. Distribution Format Analysis

## 3.1 Candidate Formats

| Format | Pros | Cons | Fit for Quotey |
|---|---|---|---|
| `cargo install` | trivial for Rust users | requires Rust toolchain; slow install from source | acceptable for developers, not default for operators |
| GitHub Releases binaries | no Rust requirement; fast install | requires release automation and signing discipline | **primary channel** |
| Homebrew formula | strong macOS/Linux UX | tap maintenance overhead | phase 2 convenience channel |
| Container image | predictable server runtime | not "single binary on host" UX; ops overhead | optional for server deployments |
| Native OS packages (`deb`/`rpm`/`msi`) | enterprise-native ops workflows | packaging/signing complexity | phase 2+ |

## 3.2 Recommended Channel Policy

1. **Primary:** GitHub Releases prebuilt binaries + installer scripts (shell and PowerShell).
2. **Secondary:** `cargo install` for developers and contributors.
3. **Deferred:** Homebrew tap and OS-native packages after first stable operator cohort.

## 4. Cross-Compilation Strategy

## 4.1 Target Matrix (v1)

| OS | Target Triple | Priority |
|---|---|---|
| Linux x86_64 | `x86_64-unknown-linux-gnu` | P0 |
| Linux ARM64 | `aarch64-unknown-linux-gnu` | P1 |
| macOS Intel | `x86_64-apple-darwin` | P1 |
| macOS Apple Silicon | `aarch64-apple-darwin` | P0 |
| Windows x86_64 | `x86_64-pc-windows-msvc` | P0 |

Notes:

1. Linux `musl` variants can be added when static-link portability becomes mandatory.
2. macOS and Windows notarization/signing remain separate pipeline concerns.

## 4.2 Tooling Decision

1. Use `cargo-dist` as the primary release artifact tool (build matrix + installers).
2. Use `cross` for containerized cross-build fallback when host runners are insufficient.
3. Use `cargo-zigbuild` specifically for Linux cross-linking/static portability scenarios.

Reasoning:

- `cargo-dist` covers release assembly and installer generation.
- `cross` and `cargo-zigbuild` are tactical build backends, not end-to-end release orchestration replacements.

## 5. Binary Optimization Strategy

## 5.1 Release Profile Recommendations

Apply an explicit `[profile.release]` policy:

1. `lto = "thin"` by default (good size/runtime trade-off),
2. `codegen-units = 1` for final release jobs,
3. `strip = "symbols"` to reduce binary size,
4. `panic = "abort"` only if crash reporting requirements permit.

## 5.2 Compression Policy

1. Do **not** make UPX compression default in v1.
2. Allow optional compressed artifacts for bandwidth-constrained channels only after validation.

Why:

- UPX can trigger endpoint security false positives and complicate incident forensics.

## 6. Update Mechanism Design

## 6.1 Requirements for Quotey Updates

1. Never orphan or silently corrupt the local SQLite file.
2. Preserve deterministic migration behavior across upgrades.
3. Keep rollback practical for operators with minimal tooling.

## 6.2 Recommended Update Flow (v1)

1. Check availability against signed release metadata.
2. Download artifact and verify checksum/signature.
3. Snapshot current executable and database (`.db`, `-wal`, `-shm`) before replacement.
4. Replace executable atomically where possible.
5. Run startup/bootstrap migration path (or explicit `quotey migrate`) to converge schema.
6. If migration fails, restore binary and database snapshot.

## 6.3 Updater Implementation Path

1. Start with installer-script based update path generated by `cargo-dist`.
2. Add in-app updater later using `axoupdater` if UX requires one-command self-update.
3. Keep update check/apply as explicit operator action (no forced background mutation in v1).

## 7. CI/CD Release Architecture

## 7.1 Recommended Pipeline

1. Developer merges to `main`.
2. `release-plz release-pr` opens/updates release PR with version/changelog.
3. On release/tag event, `cargo-dist` builds target matrix artifacts and installers.
4. CI publishes checksums plus provenance/attestation artifacts.
5. Release notes include install/update commands per platform.

## 7.2 Quality Gates Before Publish

1. `cargo fmt --check`
2. `cargo clippy --workspace --all-targets -- -D warnings`
3. `cargo test --workspace`
4. migration smoke check (`quotey migrate` against fresh db)
5. startup smoke check (`quotey-server` boot + graceful shutdown path)

## 8. Installation Guide (Operator-Oriented)

## 8.1 Linux/macOS (Installer Script)

1. Download the release installer script from the GitHub release.
2. Install to a user-local bin directory (or operator-chosen path).
3. Run `quotey-cli doctor`.
4. Run `quotey-cli migrate`.
5. Start service/binary with managed env config.

## 8.2 Windows (PowerShell Installer)

1. Use release PowerShell installer artifact.
2. Validate executable path and PATH update.
3. Run `quotey-cli doctor` and `quotey-cli migrate`.
4. Start via service/task runner according to deployment model.

## 8.3 Developer Install (Fallback)

1. `cargo install --path crates/cli` for local contributor workflows only.

## 9. Deployment Pattern Notes

## 9.1 Desktop/Laptop Deployment

1. Local user install with scoped config and data path.
2. Manual, user-initiated updates are acceptable.

## 9.2 Small Business Server / VM

1. Pin explicit version in operational runbook.
2. Update during maintenance window with pre-flight backup.
3. Keep one previous binary + db snapshot for fast rollback.

## 9.3 Containerized Deployment

1. Optional for centralized environments.
2. Use persistent volume for SQLite data.
3. Treat image rollout + schema migration sequencing as one controlled operation.

## 10. Platform-Specific Gotchas

1. **Linux:** glibc compatibility can vary by distro baseline; test oldest supported base image.
2. **macOS:** cross-signed/notarized binaries are a separate release concern.
3. **Windows:** Authenticode signing is strongly recommended for enterprise deployment.
4. **SQLite local-first:** backup must include sidecar files (`-wal`, `-shm`) when WAL is active.

## 11. Risk Register and Mitigations

| Risk | Impact | Mitigation |
|---|---|---|
| unsigned artifacts or weak provenance | supply-chain trust gap | checksums + attestations + signing policy |
| migration failure during update | service disruption/data risk | pre-update snapshots + automatic rollback path |
| target matrix drift | broken platform support | CI matrix enforcement + smoke tests per artifact |
| over-optimized binaries (size-only focus) | runtime regressions | benchmark gate before changing release profile |
| updater automation bugs | bad in-place upgrades | staged rollout and explicit operator invocation in v1 |

## 12. Deliverable Mapping for `bd-256v.9`

Requested deliverables mapped:

1. **Distribution strategy document:** Sections 3 and 7.
2. **Cross-compilation setup:** Section 4.
3. **CI/CD for releases:** Section 7.
4. **Update mechanism design:** Section 6.
5. **Installation guide:** Section 8.
6. **Platform-specific notes:** Section 10.
7. **ADR:** `.planning/research/ADR-009-Distribution-Architecture.md`.

## 13. References (Primary Sources)

1. Cargo Dist repository and docs: https://github.com/axodotdev/cargo-dist
2. Cargo Dist book: https://axodotdev.github.io/cargo-dist/book/
3. release-plz docs: https://release-plz.dev/docs/introduction/
4. release-plz getting started: https://release-plz.dev/docs/usage/getting-started/
5. release-plz release PR command: https://release-plz.dev/docs/commands/release-pr/
6. cross (cross-compilation helper): https://github.com/cross-rs/cross
7. cargo-zigbuild: https://github.com/rust-cross/cargo-zigbuild
8. Cargo profile tuning reference: https://doc.rust-lang.org/cargo/reference/profiles.html
9. Rustup cross-compilation notes: https://rust-lang.github.io/rustup/cross-compilation.html
10. Axo updater project: https://github.com/axodotdev/axoupdater
